---
title: compose安卓组件
date: 2025-4-17
category: 安卓
tags: [Android]
excerpt: 这篇文章将记录一下我最初的安卓学习，展示一些自己做的小组件
---

本人跟着安卓开发者手册学下来，又自己找了一个项目跟着做，发现想在项目中融入自己的小idea这个过程并不是很顺利，去搜资料发现网上安卓相关资料并不多，问ai，ai有时也和我胡言乱语，所以为了记录学习安卓的各种问题，也算是为网上稀少的安卓开发相关资料贡献一份自己的力量，这篇博客就是展示一些自己做的小组件，我可能还会讲讲当时折磨我好久的原因是什么，希望避坑吧。
# 一. 搜索组件
```kotlin
@Composable  
fun CustomEditSearch(  
    text: String = "",  
    onValueChange: (String) -> Unit,  
    modifier: Modifier,  
    hint: String = "请输入",  
    @DrawableRes startIcon: Int = -1,  
    iconSpacing: Dp = 6.dp,  
    enabled: Boolean = true,  
    readOnly: Boolean = false,  
    textStyle: TextStyle = TextStyle.Default,  
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,  
    keyboardActions: KeyboardActions = KeyboardActions.Default,  
    visualTransformation: VisualTransformation = VisualTransformation.None,  
    cursorBrush: Brush = SolidColor(MaterialTheme.colorScheme.primary)  
) {  
    // 焦点, 用于控制是否显示 右侧叉号  
    var hasFocus by remember { mutableStateOf(false) }  
  
    BasicTextField(  
        value = text,  
        onValueChange = onValueChange,  
        modifier = modifier.onFocusChanged { hasFocus = it.isFocused },  
        singleLine = true,  
        enabled = enabled,  
        readOnly = readOnly,  
        textStyle = textStyle,  
        keyboardOptions = keyboardOptions,  
        keyboardActions = keyboardActions,  
        visualTransformation = visualTransformation,  
        cursorBrush = cursorBrush,  
        decorationBox = @Composable { innerTextField ->  
            Row(  
                modifier = Modifier.fillMaxWidth(),  
                verticalAlignment = Alignment.CenterVertically  
            ) {  
                // -1 不显示 左侧Icon  
                if (startIcon != -1) {  
                    Image(painter = painterResource(id = startIcon), contentDescription = null)  
                    Spacer(modifier = Modifier.width(iconSpacing))  
                }  
  
                Box(modifier = Modifier.weight(1f)) {  
                    // 当空字符时, 显示hint  
                    if (text.isEmpty())  
                        Text(text = hint, color = Color.Gray, style = textStyle)  
  
                    // 原本输入框的内容  
                    innerTextField()  
                }  
  
                // 存在焦点 且 有输入内容时. 显示叉号  
                if (hasFocus && text.isNotEmpty()) {  
                    Icon(imageVector = Icons.Filled.Clear, // 清除图标  
                        contentDescription = null,  
                        // 点击就清空text  
                        modifier = Modifier.clickable { onValueChange.invoke("") })  
                }  
                Icon(  
                    imageVector = Icons.Filled.Search,  
                    contentDescription = null,  
                    modifier = Modifier  
                        .padding(start = 10.dp)  
                )  
            }  
        }    )  
}
```
使用BasicTextField定制化程度更高，我最开始一直在TextField的基础上稿，弄出的东西就很难看。
# 二. 轮播图组件
```kotlin
@Composable  
fun SwiperContent(vm: MainViewModel = viewModel()){  
  
    val realPageCount = vm.swiperData.size  
    val initialPage = 1000 * realPageCount // 从一个较大的页面开始，营造无限滚动的感觉  
    var isPlaying by remember { mutableStateOf(true) }  
  
    val pagerState = rememberPagerState(initialPage = initialPage) {  
        Int.MAX_VALUE // 几乎无限的页面  
    }  
  
    if (realPageCount <= 1) {  
        if (realPageCount == 1) {  
            AsyncImage(  
                model = vm.swiperData[0].imageUrl,  
                contentDescription = null,  
                modifier = Modifier  
                    .fillMaxWidth()  
                    .aspectRatio(7 / 3f)  
                    .padding(horizontal = 8.dp)  
                    .clip(RoundedCornerShape(8.dp)),  
                contentScale = ContentScale.Crop  
            )  
        }  
        return  
    }  
      
    // 轮播效果  
    LaunchedEffect(isPlaying) {  
        if (!isPlaying) return@LaunchedEffect  
        while (true) {  
            delay(3000)   
            // 在切换页面之前，确认是否正在被用户操作  
            if (!pagerState.isScrollInProgress) {  
                withContext(Dispatchers.Main) {  
                    pagerState.animateScrollToPage(pagerState.currentPage + 1)  
                }  
            }  
        }  
    }  
  
    // 判断用户是否有自己滑动，如果滑动则不进行轮播  
    LaunchedEffect(pagerState.isScrollInProgress) { // 使用稳定的 Key        
        snapshotFlow { pagerState.isScrollInProgress }  
            .debounce(500) // 防抖 500ms            
            .distinctUntilChanged() // 去重  
            .collect { isScrolling ->  
                if (isScrolling) {  
                    isPlaying = false  
                } else {  
                    isPlaying = true  
                }  
            }  
    }  
    
    // 判断是否接近边界，重新定位位置  
    LaunchedEffect(pagerState.currentPage) {  
        if (pagerState.currentPage <= 10) {  
            pagerState.scrollToPage(1000 * realPageCount)  
        } else if (pagerState.currentPage >= Int.MAX_VALUE - 10) {  
            pagerState.scrollToPage(1000 * realPageCount)  
        }  
    }  
  
    // 显示轮播图  
    HorizontalPager(  
        state = pagerState,  
        modifier = Modifier.padding(horizontal = 8.dp).clip(RoundedCornerShape(8.dp))  
    ) {index ->  
        val page = index % realPageCount  
        AsyncImage(  
            model = vm.swiperData[page].imageUrl,  
            contentDescription = null,  
            modifier = Modifier.fillMaxWidth().aspectRatio(7/3f),  
            contentScale = ContentScale.Crop,  
        )  
    }  
}
```
传入自己的ViewModel，使用ViewModel中的图片数据，在判断用户是否有自己滑动，如果滑动则不进行轮播这个部分，使用了debounce防抖处理**快速连续的事件流**，确保只对最后一个事件做出响应，并忽略中间的事件。我最开始没有使用这个导致状态不断切换使轮播图没有自动变换。
# 三. 轮播通知
```kotlin
@Composable  
fun NotificationContent(vm: MainViewModel){  
    Row(modifier = Modifier  
        .padding(8.dp)  
        .clip(RoundedCornerShape(8.dp))  
        .background(Color(0x66149EE7))  
        .height(45.dp)  
        .padding(horizontal = 8.dp),  
        verticalAlignment = Alignment.CenterVertically,  
        horizontalArrangement = Arrangement.SpaceBetween  
    ){  
        val realPageCount = vm.notifications.size  
        val initialPage = 1000 * realPageCount // 从一个较大的页面开始，营造无限滚动的感觉  
        var isPlaying by remember { mutableStateOf(true) }  
  
        val pagerState = rememberPagerState(initialPage = initialPage) {  
            Int.MAX_VALUE // 几乎无限的页面  
        }  
  
        LaunchedEffect(isPlaying) {  
            if (!isPlaying) return@LaunchedEffect  
            while (true) {  
                delay(3000)  
                // 在切换页面之前，确认是否正在被用户操作  
                if (!pagerState.isScrollInProgress) {  
                    withContext(Dispatchers.Main) {  
                        pagerState.animateScrollToPage(pagerState.currentPage + 1)  
                    }  
                }  
            }  
        }  
  
        // 判断用户是否有自己滑动，如果滑动则不进行轮播  
        LaunchedEffect(pagerState.isScrollInProgress) { // 使用稳定的 Key            
        snapshotFlow { pagerState.isScrollInProgress }  
                .debounce(500) // 防抖 500ms                
                .distinctUntilChanged() // 去重  
                .collect { isScrolling ->  
                    if (isScrolling) {  
                        isPlaying = false  
                    } else {  
                        isPlaying = true  
                    }  
                }  
        }  
        LaunchedEffect(pagerState.currentPage) {  
            if (pagerState.currentPage <= 10) {  
                pagerState.scrollToPage(1000 * realPageCount)  
            } else if (pagerState.currentPage >= Int.MAX_VALUE - 10) {  
                pagerState.scrollToPage(1000 * realPageCount)  
            }  
        }  
  
        Text(  
            text = "最新咨询",  
            color = Color(0xFF149EE7),  
            fontSize = 16.sp,  
        )  
        Spacer(modifier = Modifier.width(8.dp))  
        VerticalPager(state = pagerState,  
            modifier = Modifier.weight(1f),  
        ) {index ->  
            val page = index % realPageCount  
            Box(  
                modifier = Modifier.fillMaxSize(),  
                contentAlignment = Alignment.CenterStart // 内容居中  
            ) {  
                Text(  
                    text = vm.notifications[page],  
                    maxLines = 1,  
                    overflow = TextOverflow.Ellipsis,  
                    fontSize = 14.sp  
                )  
            }  
        }        Text(  
            text = "更多",  
            maxLines = 1,  
            fontSize = 14.sp,  
        )  
    }  
}
```
通知的VerticalPager组件中没有verticalAlignment参数，所以要在text外包裹box使它内容居中，还有在最外层的Row中padding的顺序也很重要

# 四.底部翻页
```kotlin
@Composable  
fun AdvancedPageNavigator(  
    currentPage: Int,  
    totalPages: Int,  
    onPageSelected: (Int) -> Unit  
) {  
    Row(  
        modifier = Modifier.padding(16.dp),  
        verticalAlignment = Alignment.CenterVertically  
    ) {  
        NavigationText("上一页", currentPage > 1) {  
            if (currentPage > 1) onPageSelected(currentPage - 1)  
        }  
  
        val pages = calculatePages(currentPage, totalPages)  
        pages.forEach { page ->  
            when (page) {  
                is PageItem.Page -> {  
                    PageBox(page.number, page.number == currentPage) {  
                        onPageSelected(page.number)  
                    }  
                }  
                is PageItem.Ellipsis -> {  
                    EllipsisBox()  
                }  
            }  
        }  
  
        NavigationText("下一页", currentPage < totalPages) {  
            if (currentPage < totalPages) onPageSelected(currentPage + 1)  
        }  
    }}  
  
@Composable  
fun PageBox(number: Int, isSelected: Boolean, onClick: () -> Unit) {  
    Box(  
        modifier = Modifier  
            .background(  
                if (isSelected) Color(0xFF005BAC) else Color.Transparent,  
                shape = RoundedCornerShape(4.dp)  
            )  
            .border(  
                1.dp,  
                if (isSelected) Color(0xFF005BAC) else Color.LightGray,  
                shape = RoundedCornerShape(4.dp)  
            )  
            .clickable { onClick() }  
            .padding(horizontal = 12.dp, vertical = 4.dp)  
    ) {  
        Text(  
            text = number.toString(),  
            color = if (isSelected) Color.White else Color(0xFF005BAC)  
        )  
    }  
}  
  
@Composable  
fun EllipsisBox() {  
    Box(modifier = Modifier) {  
        Text("...", color = Color.Gray)  
    }  
}  
  
@Composable  
fun NavigationText(text: String, enabled: Boolean, onClick: () -> Unit) {  
    Text(  
        text = text,  
        color = if (enabled) Color(0xFF005BAC) else Color.Gray,  
        fontSize = 12.sp,  
        modifier = Modifier  
            .clickable(enabled = enabled) { onClick() }  
            .padding(horizontal = 8.dp, vertical = 8.dp)  
    )  
}  
  
sealed class PageItem {  
    data class Page(val number: Int) : PageItem()  
    object Ellipsis : PageItem()  
}  
  
fun calculatePages(currentPage: Int, totalPages: Int): List<PageItem> {  
    val pages = mutableListOf<PageItem>()  
  
    if (totalPages <= 7) {  
        // 展示所有页码  
        (1..totalPages).forEach { pages.add(PageItem.Page(it)) }  
    } else {  
        // Always show first page  
        pages.add(PageItem.Page(1))  
  
        if (currentPage > 4) {  
            pages.add(PageItem.Ellipsis)  
        }  
  
        val start = maxOf(2, currentPage - 1)  
        val end = minOf(totalPages - 1, currentPage + 1)  
  
        for (i in start..end) {  
            pages.add(PageItem.Page(i))  
        }  
  
        if (currentPage < totalPages - 3) {  
            pages.add(PageItem.Ellipsis)  
        }  
  
        // Always show last page  
        pages.add(PageItem.Page(totalPages))  
    }  
  
    return pages  
}
```
