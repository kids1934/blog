---
title: 树
date: 2024-8-14
category: 计算机基础
tags: [CS, Data Structure]
readTime: 5
excerpt: 这篇文章将记录一下给新生的培训内容
---
# 树

## 1、树的基本概念

**1.树的定义**

树是n（n\>=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：有且仅有一个特定的称为根的结点。

当n\>1时，其余节点可分为m（m\>0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。

显然，树的定义是递归的，即在树的定义中又用到了自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：

1.树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。

2.树中所有结点可以有零个或多个后继。因此n个结点的树中有n-1条边。

**2.树的基本术语**

1.节点：存储数据的单元，可以是任何类型的值。

2.节点的度：该节点直接相连的边的数量。

3.根节点：仅有一个根节点，没有父节点，是树的起点。

4.子树：根节点之外的任意节点都可以作为子树的根，形成独立的树。

5.叶子节点：没有子节点的节点称为叶节点。

6.孩子结点或子结点：结点的子树的根称为该结点的孩子结点或子结点。

7.双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的双亲结点或父结点。

8.兄弟结点：同一个双亲的孩子之间互称兄弟。

9.树的深度或高度：树中结点的最大层次。

![](/img/树/img.png)

**3.树状结构的应用**

**文件系统**

最为基础的应用就是计算机中对文件的管理结构，在计算机的文件系统中，目录和文件以树形结构组织。这种结构不仅便于用户和管理员快速定位、访问和管理文件，还能有效利用存储空间。

![](/img/树/img_1.png)

**数据库索引**

数据库系统利用树形结构（如B树、B+树）来构建索引，以加快数据检索的速度。B树和B+树是平衡多路搜索树，它们通过减少磁盘I/O操作来提高查询效率。在B树中，每个节点包含多个关键字和子节点指针，所有叶子节点都在同一层。B+树则进一步优化了B树的结构，所有关键字都出现在叶子节点中，并且叶子节点之间通过指针相连，形成了有序链表，这使得范围查询更加高效。

**人工智能**

在人工智能领域，树形结构的应用非常广泛。决策树是一种常用的分类和回归方法，它通过构建一棵树来模拟人类决策过程。决策树的每个节点代表一个决策点，每个分支代表一个可能的决策结果，叶子节点则包含最终的决策输出。随机森林则是由多个决策树组成的集成学习方法，通过多个决策树的投票或平均来提高预测的准确性和鲁棒性。

## 2.二叉树

**1.二叉树的基本概念**

二叉树是一种重要的数据结构，它是由节点组成的，每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树可以为空，也可以只有一个根节点，或者有一个根节点和两个子节点。二叉树的特点是每个节点最多只能有两个子节点，这两个子节点被称为左子树和右子树

**2.遍历二叉树**

二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。

四种主要的遍历思想为：

前序遍历：根结点 ---\> 左子树 ---\> 右子树

中序遍历：左子树---\> 根结点 ---\> 右子树

后序遍历：左子树 ---\> 右子树 ---\> 根结点

层次遍历：只需按层次遍历即可

![](/img/树/img_2.png)

前序遍历结果为：A B D E C F G

中序遍历结果为：D B E A F C G

后序遍历结果为：D E B F G C A

层序遍历结果为：A B C D E F G

![](/img/树/img_3.png)

前序遍历结果为：A B D F G H I E C

中序遍历结果为：F D H G I B E A C

后序遍历结果为：F H I G D E B C A

![](/img/树/img_4.png)

前序遍历结果为：A B D G H I C E J F

中序遍历结果为：G D I H B A E J C F

后序遍历结果为：G I H D B J E F C A

## 3.二叉搜索树

**1.基本概念**

二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。  
二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：

非空左子树的所有键值小于其根结点的键值。

非空右子树的所有键值大于其根结点的键值。

左、右子树都是二叉搜索树。

**2.代码以及遍历搜索**

{% codeblock 二叉树代码 [lang:C++] [title] [url] [link text] %}
#include <stdio.h>
struct node
{
    int data; //数据域
    node* lchild; //指向左子树根节点的指针
    node* rchild; //指向右子树根节点的指针
};
node* newNode(int v) {
    node* Node = new node; //申请一个node类型变量的地址空间
    Node->data = v; //结点权值为v
    Node->lchild = Node->rchild = NULL; //初始状态下无左右孩子
    return Node; //返回新节点的地址
}
node* Find(int x, node* root){
    if (!root) return NULL; /*查找失败*/
    if (x > root->data)
        return Find(x, root->rchild); /*在右子树中继续查找*/
    else if (x < root->data)
        return Find(x, root->lchild); /*在左子树中继续查找*/
    else
        return root; /*查找成功，返回结点的找到结点的地址*/
}

void insert(node*& root, int x) {  //注意 传入的是结点指针的引用
    if (root == NULL) { //空树，即查找失败，插入结点（递归边界）
        root = newNode(x);
        return;
    }
    if (root->data > x) { //往左子树搜索
        insert(root->lchild, x);
    }
    else insert(root->rchild, x); //往右子树搜索
}
node* create(int data[], int n) {
    node* root = NULL;     //新建空根结点
    for (int i = 0; i < n; i++) {
        insert(root, data[i]); //插入二叉树
    }
    return root; //返回根节点
}
void preorder(node* root) { //前序遍历
    if (root == NULL) return; //到达空树，即递归边界
    printf("%d", root->data); //访问根节点数据域
    preorder(root->lchild); //访问左子树
    preorder(root->rchild); //访问右子树
}
void inorder(node* root) { //中序遍历
    if (root == NULL) return; //到达空树，即递归边界
    inorder(root->lchild); //访问左子树
    printf("%d", root->data); //访问根节点数据域
    inorder(root->rchild); //访问右子树
}
void postorder(node* root) { //后序遍历
    if (root == NULL) return; //到达空树，即递归边界
    preorder(root->lchild); //访问左子树
    preorder(root->rchild); //访问右子树
    printf("%d", root->data); //访问根节点数据域
}
int main() {
    int nums[10] = { 5,3,8,2,4,1,6,7,9,0 };
    node* root = create(nums, sizeof(nums)/sizeof(int));
    preorder(root);//前序遍历
    printf("\n");
    inorder(root);    //中序遍历
    printf("\n");
    postorder(root);//后序遍历
    printf("\n");
    node* x = Find(5, root);
    printf("%p", x);
    return 0;
}
{% endcodeblock %}


**3.二叉搜索树的问题**

二叉查找树比普通树查找更快，查找、插入、删除的时间复杂度为O（logN）。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变成了O（N），为了解决这种情况，出现了二叉平衡树

![](/img/树/img_5.png)

## 4.平衡二叉树

**1.基本概念**

平衡二叉树也叫AVL树，它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和左子树的高度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。所以由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。

**2.平衡因子**

BF（平衡因子）的值为：左子树高度 - 右子树高度

**3.平衡方法**

![](/img/树/img_6.png)

当我们在一个平衡二叉树中进行插入和删除操作时，可能会导致它的平衡性被破坏。如上图，本是平衡的，如果我插入了一个新值是30的节点，那么这棵树的平衡性就会被破坏，它一共破坏了节点32和节点25的平衡性，虽然破坏了2个节点的平衡性，但我们只讨论最近被破坏节点的平衡性（因为底下的处理好了，上面的节点平衡性也会随之处理好），即新插入节点30破坏了节点32的平衡性，因为新插入节点而导致平衡性被破坏的节点也叫麻烦节点，而被其破坏平衡的节点叫被破坏节点。一共把破坏平衡型的类型分为了四种，分别是LL型、RR型、LR型和RL型，每一种破坏方式都有对应的旋转方式来保持树的平衡性。

**1.LL型**

|                |                |
|:---------------|:---------------|
| ![](/img/树/img_7.png) | ![](/img/树/img_8.png) |

如上两图图，LL型也为左左型，在被破坏节点的左边的左边插入而导致失衡，则为LL型。

LL型解决方案：以被破坏节点为基础进行右旋。右旋就是根据某个节点向右旋转。

|                |                 |
|:---------------|:----------------|
| ![](/img/树/img_9.png) | ![](/img/树/img_10.png) |

**2.RR型**

|                 |                 |
|:---------------:|:----------------|
| ![](/img/树/img_11.png) | ![](/img/树/img_12.png) |

如上两图图，RR型也为右右型，在被破坏节点的右边的右边插入而导致失衡，则为RR型。

RR型解决方案：以被破坏节点为基础进行左旋。左旋就是根据某个节点向左旋转。

|                 |                 |
|:---------------:|:----------------|
| ![](/img/树/img_13.png) | ![](/img/树/img_14.png) |

**3.LR型**

![](/img/树/img_15.png)

如上图，LR型也为左右型，在被破坏节点的左边的右边插入而导致失衡，则为LR型。

LR型解决方案：以被破坏节点L（左）节点为基础先进行一次L（左）旋，再以被破坏节点为基础进行右旋。

|                 |                 |
|:----------------|:---------------:|
| ![](/img/树/img_16.png) | ![](/img/树/img_17.png) |

先以20为基础进行一次左旋。再以25为基础进行一次右旋，可以看出经过两次旋转后，该树已经平衡。

**4.RL型**

![](/img/树/img_18.png)

如上图，RL型也为右左型，在被破坏节点的右边的左边插入而导致失衡，则为RL型。

RL型解决方案：以被破坏节点R（右）节点为基础先进行一次R（右）旋，再以被破坏节点为基础进行左旋。

|                 |                 |
|:----------------|:---------------:|
| ![](/img/树/img_19.png) | ![](/img/树/img_20.png) |

先以25为基础进行一次右旋。再以20为基础进行一次右旋，可以看出经过两次旋转后，该树已经平衡。

**5.总结**

处理方式分为两大类：

RR型和LL型，以被破坏节点为基础进行其反向的旋转即可，即RR型进行左旋，LL型进行右旋。

RL型和LR型，先以被破坏节点的LR或RL首字母的节点进行LR或RL首字母旋转，再以被破坏节点为基础进行LR或RL尾字母旋转，即RL型先以被破坏节点的R（右）节点为基础进行一次R（右）选，再以被破坏节点为基础进行一次L（左）旋；LR旋先以被破坏节点的L（左）节点为基础进行一次L（左）选，再以被破坏节点为基础进行一次R（右）旋。

**4.代码实现**

{% codeblock 平衡二叉树代码 [lang:C++] [title] [url] [link text] %}
#include<iostream>

typedef int ElenmentType;
//平衡二叉树的结构
typedef struct AVLNode {
    int depth;//深度
    struct AVLNode* left;
    struct AVLNode* right;
    struct AVLNode* parent;
    ElenmentType value;
    //构造器
    AVLNode(ElenmentType value = 0) {
    parent = NULL;
    depth = 0;
    left = right = NULL;
    this->value = value;
}
}Tree;
Tree* LL_rotate(Tree* root) {//LL执行右旋
    //root是原来的平衡二叉树的根结点
    Tree* temp;//临时变量
    //获取根结点的左孩子
    temp = root->left;
    //根结点的左孩子变更为其原来左孩子的右孩子
    root->left = temp->right;
    //原来的根结点的左孩子变为了根结点
    temp->right = root;
    return temp;
}
Tree* RR_rotate(Tree* root) {//RR执行左旋
    Tree* temp;
    temp = root->right;//获取根结点的右孩子
    root->right = temp->left;//根结点的右孩子变为其原来右孩子的左孩子
    temp->left = root;//原来的根结点的右孩子变为了新的根结点
    return temp;
}
Tree* LR_rotate(Tree* root) {
    Tree* temp;
    temp = root->left;
    root->left = RR_rotate(temp);
    return LL_rotate(root);
}
Tree* RL_rotate(Tree* root) {
    Tree* temp;
    temp = root->right;
    root->right = LL_rotate(temp);
    return RR_rotate(root);
}
int height(const Tree* root)//求树高，递归
{
    if (root == NULL)
        return 0;
    return std::max(height(root->left),
    height(root->right)) + 1;
}
int diff(const Tree* root)//求平衡因子，即当前节点左右子树的差
{
    return height(root->left) - height(root->right);
}

Tree* Balance(Tree* root)
{
    int balanceFactor = diff(root);//diff用来计算平衡因子（左右子树高度差）
    if (balanceFactor > 1)//左子树高于右子树
    {
        if (diff(root->left) > 0)//LL的情况
        root = LL_rotate(root);
        else//LR的情况
        root = LR_rotate(root);
    }
    else if (balanceFactor < -1)//右子树高于左子树
    {
    if (diff(root->right) > 0)//RL的情况
        root = RL_rotate(root);
        else//RR的情况
        root = RR_rotate(root);
    }
    return root;
}
//插入结点
Tree* Insert(Tree* root, ElenmentType k)
{
    if (NULL == root){
        root = new AVLNode(k);//如果根结点为null，则直接将值为根结点
        if (root == NULL)
        printf("创建失败");
        return root;
    }//递归返回条件
    else if (k < root->value)
    {
        root->left = Insert(root->left, k);//递归左子树
        //balance operation
        root = Balance(root);//平衡操作包含了四种旋转
    }
    else if (k > root->value)
    {
        root->right = Insert(root->right, k);//递归右子树
        //balance operation
        root = Balance(root);//平衡操作包含了四种旋转
    }
    return root;
}
//中序遍历,获取的数列是有序的
void displayTree(Tree* node) {
    if (node == NULL) return;
    if (node->left != NULL) {
            displayTree(node->left);
    }
    printf("%d ", node->value);
    if (node->right != NULL) {
            displayTree(node->right);
    }
}
//查找value，成功则返回该结点
Tree* binaryTreeSearch(Tree* node, int value) {
    if (node->value == value)
    return node;
    else if (node->value > value) {
        if (node->left != NULL)
        return binaryTreeSearch(node->left, value);
        else return NULL;
    }
    else {
        if (node->right != NULL)
        return binaryTreeSearch(node->right, value);
        else
        return NULL;
    }
}
int main() {
    int a[10] = { 12,13,55,66,44,77,99,33,46,79 };
    Tree* root = NULL;
    printf("第一次构建的平衡二叉树中序遍历：");
    for (int i = 0; i < 10; i++) {
    root = Insert(root, a[i]);
    }
    displayTree(root);
    printf("\n");
    //查找33
    int value = 33;
    Tree* obj;
    if ((obj = binaryTreeSearch(root, value)) == NULL) {
    printf("%d值不存在", value);
    }
    else printf("%d值存在,地址是%p", value, obj);
    printf("\n");
    root = Insert(root, 5);
    printf("插入了结点值为5的结点以后，中序遍历：");
    displayTree(root); 
    return 0;
}

{% endcodeblock %}

## 5.B树

**1.概述**

B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。

**2.特点**

多路平衡树：多路平衡树其实就是多叉平衡树，每个节点都有多个指向孩子节点的指针以及键值。通常，一颗m阶的B树有k个子节点，有k-1个关键字，而k的取值范围为\[ceil(m/2),m\]（celi表示向上取整）。例如一颗3阶的B树，最多有3个孩子2个关键字。

键值有序：每个节点中包含多个关键字，这些关键字是有序的。节点中每个关键字都将子节点切割成两部分，左边部分的节点的所有关键字的值一定是小于该关键字的，右边节点的所有关键字的值都是大于该关键字的，这一点跟二叉搜索树的性质相同。

树的高度平衡：所有叶子节点的深度都是一样的，站在AVL树的角度讲，每个节点的平衡因子都是0。

高效的磁盘读写：B树被设计用于在磁盘上高效的存储和读取数据。通过每个节点都有多个键值和多个字节的指针，从而减少磁盘的读写次数，以提高读写效率。

**3.定义**

一颗m阶的B树定义如下：

1）每个结点最多有m-1个key。

2）根结点最少可以只有1个key。

3）非根结点至少有Math.ceil(m/2)-1个key。

4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

![](/img/树/img_21.png)

上图是一颗阶数为4的B树。在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。我们将一个key和其对应的data称为一个记录。在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速度，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。

**4.插入操作**

插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。

1）根据要插入的key的值，找到叶子结点并插入。

2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

a）在空树中插入39

![](/img/树/img_22.png)

此时根结点就一个key，此时根结点也是叶子结点

b）继续插入22，97和41

![](/img/树/img_23.png)

根结点此时有4个key

c）继续插入53

插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。

![](/img/树/img_24.png)

d）依次插入13，21，40，同样会造成分裂，结果如下图所示。

![](/img/树/img_25.png)

e）依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。

![](/img/树/img_26.png)

f）插入key值为26的记录，插入后的结果如下图所示。

![](/img/树/img_27.png)

当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。

![](/img/树/img_28.png)

进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。

![](/img/树/img_29.png)

分裂后当前结点指向新的根，此时无需调整。

g）最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。

![](/img/树/img_30.png)

**5.删除操作**

删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。

1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步

2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。

3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。

否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。

下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key

a）原始状态

![](/img/树/img_31.png)

b）在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。

![](/img/树/img_32.png)

c）在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。

![](/img/树/img_33.png)

删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。

![](/img/树/img_34.png)

d）在上述情况下接着32，结果如下图。

![](/img/树/img_35.png)

当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。

![](/img/树/img_36.png)

当前结点key的个数满足条件，故删除结束。

e）上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。

![](/img/树/img_37.png)

同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。

![](/img/树/img_38.png)

同理，对于当前结点而言只能继续合并了，最后结果如下所示。

![](/img/树/img_39.png)

合并后结点当前结点满足条件，删除结束。

**6.查找操作**

以查找6为例子：

![](/img/树/img_40.png)

B树的查找包括两个基本操作： ① 在B树中找结点 ② 在结点中找关键字。

更具体的说，根据指针拿到一个结点，是一次磁盘I/O，即第①个动作是在磁盘上进行的；根据有序关键字查找目标，是一次顺序查找或二分查找，即第②个动作是在内存中进行的。

这时，你是不是已经明白了为什么数据库要使用B树而非二叉搜索树呢？

B树和二叉查找树的目的都是查找，查找算法的瓶颈是什么呢？比较的次数。但是，数据库查询的瓶颈是什么呢？磁盘I/O的次数。在内存中比较的时间，在磁盘I/O的时间面前完全可以忽略。况且，B-Tree和BST在比较次数上其实相差无几。

把B-Tree和BST摆在一起不难看出，B-Tree比BST矮胖的多。高度更小，说明磁盘I/O次数越少，自然性能越好！当数据库非常非常非常大时，B树的一个结点就是放在一个磁盘块上的，对于磁盘I/O次数的节省也会到达极致。

## 6.B+树
**1.特点**
B+ 树与 B 树差异的点，主要是以下这几点：
1. 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引。
2. 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表。
3. 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。
4. 非叶子节点中有多少个子节点，就有多少个索引。
![](/img/树/img_41.png)
**2.在存储上的优势**
MySQL数据库里的InnoDB存储引擎就是使用B+树进行数据存储的。
下面通过三个方面，比较下 B+ 和 B 树的性能区别。
**1、单点查询**
B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
**2、插入和删除效率**
B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。
B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：
**3、范围查询**
B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。
## 7.总结
二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。
为了解决二分查找树退化成链表的问题，就出现了平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。
B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构。
原因有：
1. B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
2. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化。
3. B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。